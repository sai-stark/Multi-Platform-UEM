import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { GState } from 'jspdf';

export const exportToPDF = (
  data: any[],
  headers: string[],
  filename: string,
  title: string,
  userName: string,
  dataMapping?: Record<string, string>
) => {
  const pdf = new jsPDF();
  const year = new Date().getFullYear();

  // Add title
  pdf.setFontSize(20);
  pdf.text(title, 20, 20);

  // Add timestamp
  pdf.setFontSize(10);
  pdf.text(`Generated on: ${new Date().toLocaleString()}`, 20, 30);

  // Add generated by
  pdf.setFontSize(10);
  pdf.text(`Generated by: ${userName}`, 20, 36);

  // Create table
  autoTable(pdf, {
    head: [headers],
    body: data.map(item => headers.map(header => {
      if (dataMapping && dataMapping[header]) {
        return item[dataMapping[header]] !== undefined && item[dataMapping[header]] !== null ? item[dataMapping[header]] : '';
      }
      return item[header] !== undefined && item[header] !== null ? item[header] : '';
    })),
    startY: 44,
    theme: 'grid',
    styles: { fontSize: 8 },
    didDrawPage: function () {
      // Watermark at the bottom center
      pdf.setFontSize(12);
      pdf.setTextColor(150);
      pdf.text(
        `© ${year} Centre for Development of Telematics. All rights reserved.`,
        pdf.internal.pageSize.getWidth() / 2,
        pdf.internal.pageSize.getHeight() - 10,
        { align: 'center' }
      );

      // --- Watermark in a beautiful diagonal pattern ---
      const watermarkText = `© ${year} Centre for Development of Telematics.`;
      const fontSize = 10;
      const opacity = 0.12; // Slightly less transparent for better visibility
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      // Create a diagonal grid pattern
      const spacing = 80; // Distance between watermarks
      const offsetX = 30; // Starting X offset
      const offsetY = 30; // Starting Y offset
      
      // Use GState for opacity if available
      if (typeof pdf.setGState === 'function' && typeof GState === 'function') {
        pdf.setGState(new GState({ opacity })); // Set opacity
        pdf.setTextColor(100, 100, 100); // Gray
        pdf.setFontSize(fontSize);
        
        // Create diagonal pattern from top-left to bottom-right
        for (let y = offsetY; y < pageHeight - 40; y += spacing) {
          for (let x = offsetX; x < pageWidth - 60; x += spacing) {
            pdf.text(watermarkText, x, y, { angle: 45 });
          }
        }
        
        // Create diagonal pattern from top-right to bottom-left (offset)
        for (let y = offsetY + spacing/2; y < pageHeight - 40; y += spacing) {
          for (let x = offsetX + spacing/2; x < pageWidth - 60; x += spacing) {
            pdf.text(watermarkText, x, y, { angle: -45 });
          }
        }
        
        pdf.setGState(new GState({ opacity: 1 })); // Reset opacity
      } else {
        // Fallback: no opacity, just rotated text
        pdf.setTextColor(180, 180, 180);
        pdf.setFontSize(fontSize);
        
        // Create diagonal pattern from top-left to bottom-right
        for (let y = offsetY; y < pageHeight - 40; y += spacing) {
          for (let x = offsetX; x < pageWidth - 60; x += spacing) {
            pdf.text(watermarkText, x, y, { angle: 45 });
          }
        }
        
        // Create diagonal pattern from top-right to bottom-left (offset)
        for (let y = offsetY + spacing/2; y < pageHeight - 40; y += spacing) {
          for (let x = offsetX + spacing/2; x < pageWidth - 60; x += spacing) {
            pdf.text(watermarkText, x, y, { angle: -45 });
          }
        }
      }
    }
  });

  pdf.save(`${filename}.pdf`);
};

export const exportToCSV = (
  data: any[],
  headers: string[],
  filename: string,
  dataMapping?: Record<string, string>
) => {
  // Create CSV content
  const csvHeaders = headers.join(',');
  const csvRows = data.map(item => 
    headers.map(header => {
      let value = '';
      if (dataMapping && dataMapping[header]) {
        value = item[dataMapping[header]] !== undefined && item[dataMapping[header]] !== null ? item[dataMapping[header]] : '';
      } else {
        value = item[header] !== undefined && item[header] !== null ? item[header] : '';
      }
      // Escape commas and quotes in CSV
      if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
        value = `"${value.replace(/"/g, '""')}"`;
      }
      return value;
    }).join(',')
  );
  
  const csvContent = [csvHeaders, ...csvRows].join('\n');
  
  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
